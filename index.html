<!DOCTYPE html>

<html>

  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta charset="utf-8">



    <title>borzov.ca/texts/flaky (Flaky: datatypes for real world quantities)</title>

    <link rel="stylesheet" href="./css/style.css" type="text/css">

    <link rel="stylesheet" href="./css/_pygments.css" type="text/css">

      <style type="text/css"></style>

      <script type="text/javascript" src="./js/latexit.js"></script>

  </head>

  <body screen_capture_injected="true">

    <div class="container">

      <div class="header">

        <a href="http://www.borzov.ca">Peter Borzov</a>'s code and writings<br>

        <a href="http://www.borzov.ca">borzov.ca</a> / texts / flaky (May, 2013)



      </div>

      <div class="navigation">

        <ul>

          <li><a href="https://github.com/dborzov"><img src="./css/octocat.png" width="20">Github</a>

        </li></ul>

      </div>



      <div class="body">
<h1>Flaky: datatypes for real world quantities</h1>

<h3><em>Abstract:</em> Modern datatypes for quantities (such as length, time or a number) should employ ideas from the functional programming: keep track of when the rounding errors arise,  support defining with functions, represent results appropriately to the context. Flaky, an open source framework, wants to make things right.</h3>

<p><a href="https://en.wikipedia.org/wiki/Floating_point">Floating point datatype</a> is the de-facto standard for real world quantities. Whether it is your GPS coordinates or sizes of the bridge nearby (likely designed in AutoCAD), this datatype lies in the foundation of every system. Since its introduction in the dawn of computing, floating point was accepted almost universally.</p>

<p>Advantages such as scalability, resilience and ease of use make floating point the datatype of choice again and again. However, it is also fragile and prone to errors. This limitations are well known, of course, and could be minimized with appropriate  expertise and focus.</p>

<p>And yet I believe that we, as an industry, could do better. Number representation based on the ideas of functional programming minimizes flaws characteristic to the floating point datatypes. And it can be made as resilient and scalable as the floating point. In this article, I outline why I decided to write Flaky, an open source library that attempts to implement such concepts.</p>

<p>In the first section we will glance at illustrating cases of when floating point breaks and try to understand what flaws should be addressed. We then look at other initiatives in this space. Finally, I introduce the design that I came up with for Flaky.</p>

<h2>When floating point fails</h2>

<p>Let us consider illustrative cases of when floating point representation leads to dramatically wrong answers.</p>

<h4>Accumulating errors</h4>

<p>Well, this one is obvious. When the number cannot be represented exactly, it has to be rounded up. These rounding errors can accumulate and can lead to silly results.</p>

<p>Let us, for example, take the square root of a number several times, and then try to reproduce the original value with the reversal operation (that is, taking squares)</p>

<pre><code> 
# price.py listing, a Python script
import math
INITIAL_VALUE=1.9934545345

def reversable_iterations(iteration_number):
    test_floating = INITIAL_VALUE
    for i in range(iteration_number):
        test_floating = math.sqrt(test_floating)
    for i in range(iteration_number):
        test_floating = test_floating**2
    return 'with '+str(iteration_number)+' iterations, we get '+str(test_floating)

print 'The intial value is ',INITIAL_VALUE
print reversable_iterations(1)
print reversable_iterations(10)
print reversable_iterations(20)
print reversable_iterations(40)
print reversable_iterations(50)
print reversable_iterations(60)
</code></pre>

<p>This yields:</p>

<pre><code> 
The intial value is  1.9934545345
with 1 iterations, we get 1.9934545345
with 10 iterations, we get 1.9934545345
with 20 iterations, we get 1.99345453444
with 40 iterations, we get 1.99311204568
with 50 iterations, we get 1.64872126455
with 60 iterations, we get 1.0
</code></pre>

<p>That the end result breaks is hardly a  surprise. Moreover, a similar effect could be achieved for any number representation datatype. Just from the general principles, if the size  of the <a href="http://en.wikipedia.org/wiki/Kolmogorov_complexity">Kolmogorov complexity</a> of a number is larger than the memory allocated for the datatype, these types of errors cannot be ruled out.</p>

<p>What I wanted to emphasize here instead is the total equanimity of the floating type. It is very hard to understand what is going on at various stages. In my opinion, this is an incredible engineering design flaw.</p>

<p>To see what I mean, let us figure out why the error is of order of 10% for 50 iterations, but converges to a wrong answer at 60. To do this we have to know how the number is represented internally, look up the default  <a href="https://en.wikipedia.org/wiki/Significand">mantissa/significand</a> size for the programming language of our choice and make the estimation calculation on a piece of paper.</p>

<p>The lack of the uncertainty estimation defeats the whole purpose of any computation.</p>

<h4>The quadratic equation</h4>

<p>Even writing a program that solves the quadratic equation
for arbitrary constant values is a serious task.
For example, let us consider the following equation
</p><center><div lang="latex">
<img src="./img/quadratic.gif" alt="Img" />
</div></center><br><p>
Note that there is no constant term and thus one solution is simply zero. However, the naive solution with the quadratic formula fails to reflect this. Here is the first Google result for "quadratic equation solver":</p>

<p></p><center><div lang="latex">
<img src="./img/QuadraticEquation.png" alt="Img" />
</div></center><br><p>
For the general case implementation, we must treat each marginal case separately. First, if the constant term is zero, then if the quadratic term is absent, and so on, one by one.</p>

<p>Quadratic equation is the simplest case of the numerical problem imaginable. Yet even here we see that one needs to manually implement basic calculus logic behind the known solution.</p>

<h4>Scaling does not match the problem</h4>

<p>Let us once again consider the quadratic equation, but this time in terms of the new variable we introduce
</p><center><div lang="latex">
y = \frac{\textrm{exp}(x)}{1 + \textrm{exp}(x)}
</div></center><br><p>
The quadratic equation in terms of y looks as follows
</p><center><div lang="latex">
a \textrm{ log}^2 (\frac{y}{1-y}) + b \textrm{ log} (\frac{y}{1-y}) + c = 0
</div></center><br><p>
Here is what the plot of the definition of the y function looks like
</p><center><div lang="latex">
<img src="img/softThreshold.png" alt="Img" />
</div></center><br><p>
The variable y "maps" the whole x range to its (0,1) range. This function is also known as the soft threshold.</p>

<p>Attempting to solve this problem numerically in terms of y should be quite challenging. The number representation for y means that all the "graining" for sufficiently large x values (say, x>5) becomes too rude.</p>

<p>That is, the number representation for the floating point
</p><center><div lang="latex">
\underbrace{\text{integer}}_{\text{mantissa}} \cdot \text{base}^\text{exponent}
</div></center><br><p> offers the scale that is not appropriate for this problem. The solutions for large x should fail spectacularly. Interestingly, the solutions with the y going to the zero limit (x going negative, for example, x&lt;-5) will be a little more resilient. The lack of the constant term (1. for large x) means that the base of the exponent will scale down gracefully.</p>

<p>How does this issue work for the (relatively) real world problems? Let me share my personal experience. In our research study on <a href="http://prl.aps.org/abstract/PRL/v110/i14/e145301">the physics of ultracold gases in 2D</a> we derived a complex equation we ended up solving numerically. The solution function was diverging logarithmically in the limit in which we were interested</p>

<p></p><center><div lang="latex"> f(x) =  \textrm{Log}( x )^{w} + \text{ non-diverging terms }, x \rightarrow 0 </div></center><br><p></p>

<p>However, it turned out practically impossible to learn the order of the divergence w from this numerical solution. The floating point representation meant that the log of the number is represented inefficiently for the problem.</p>

<p>The solution was to introduce the new variable
</p><center><div lang="latex">
z = -\textrm{Log}( x )
</div></center><br><p>
and express the whole problem and the solution in terms of z.</p>

<p>Matching the number representation scale to the problem in the general case, is of course, impossible. It depends on the interpretation of the problem , what we are actually interested in.</p>

<p>However, it would have been helpful if it was possible to tweak the scaling used without too much hassle.</p>

<h4>Summary</h4>

<p>Here is how the new quantity datatypes could be better:</p>

<ul>
<li>We saw in the example of accumulating errors that every operation performed with the number should be traceable. Errors and uncertainties should be recorded from each operation and reported when needed.</li>
<li>With the quadratic equation solver it is obvious that tracing analytic expressions used for computations allow for automatic implementation of the marginal cases and can save the developer a lot of time.</li>
<li>Datatype representation scaling should match the problem at hand and not be fixed. Tools must exist to do this with ease.</li>
</ul>

<h2>Doing things right</h2>

<blockquote>
  <p>An infinite number of mathematicians walk into a bar. The first orders a beer. The second orders half a beer. The third orders a quarter of a beer. Before the next one can order, the bartender says, Youre all assholes, and pours two beers. <a href="http://www.komplexify.com/math/jokes/MathWalksIntoABar3.html">TE</a></p>
</blockquote>

<p>Now we let us discuss the solutions that can fix these issues.</p>

<h4>What is out there.</h4>

<p>Apparently, the best way to approach the problem is to use the functional programming concepts. To retain the analytical expression used for the value definition, at least to some limit, and to have tools to change it when needed.</p>

<p>A classic case where the functional number representation was implemented is the language behind Wolfram Mathematica.
Too bad that for the non-technical reasons it is apparently destined to go into obscurity and not fulfill its full potential.</p>

<p>Another example when things seem to be done right is the <a href="http://sympy.org/en/index.html">SymPy</a>, a Python package for symbolic computations. Functional number representation is very solid. It is important to note, however, that the goal of the project is to make tools for symbolic calculations, not to create a viable alternative to the floating point.</p>

<h4>Why not flaky.</h4>

<p>So we saw how to make things better and why we should. These reasons compelled me start Flaky, the open-source project for quantity datatype based on the concepts of functional programming.</p>

<p>Numbers are represented as operations to the other numbers. Together they can make up long layers (or flakes). Simplifying occurs whenever possible.</p>

<p></p><center><div lang="latex">
(\textrm{frac},4,(\textrm{pow}, 5,(\textrm{frac},1,2))) = \frac{4}{\sqrt{5}}
</div></center><br><p></p>

<p>The size parameter defines when the datatype length is judged to be too long, then the rounding up occurs. There is a logging method to keep track of it. There is also the uncertainty estimation for margins of confidence.</p>

<p>One may choose the specific representation of the number. Matching, rounding and scaling happens seamlessly.</p>

<p>Flaky is written in the <a href="http://www.golang.org">Go programming language</a>. The repository is available on <a href="https://github.com/dborzov/FlakyPastry">Github</a> (or will be soon :)) .</p>

<p>A discussion of this post is available on <a href="https://news.ycombinator.com/item?id=5731366">Hacker News</a>.</p>

      </div>

      <div class="footer">

        <p><a href="http://creativecommons.org/licenses/by-nc-sa/2.5/ca/"><img src="./css/cc.jpg" width="15"></a>Peter Borzov, 2013.

        </p>

      </div>

    </div>







</div></body>

<script>

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){

  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),

  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)

  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');



  ga('create', 'UA-41000570-1', 'dimaborzov.com');

  ga('send', 'pageview');



</script>



</html>
